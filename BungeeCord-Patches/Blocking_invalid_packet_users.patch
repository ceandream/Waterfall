Index: protocol/src/main/java/net/md_5/bungee/protocol/ChainFilter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- protocol/src/main/java/net/md_5/bungee/protocol/ChainFilter.java	(date 1572033599000)
+++ protocol/src/main/java/net/md_5/bungee/protocol/ChainFilter.java	(date 1572033599000)
@@ -0,0 +1,65 @@
+package net.md_5.bungee.protocol;
+
+import io.netty.channel.ChannelHandlerContext;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class ChainFilter extends Thread {
+
+    private static final Map<String, Integer> chains = new HashMap<>();
+    private static final Map<String, Long> alreadyBanned = new ConcurrentHashMap<>();
+
+    public static void chain(ChannelHandlerContext ctx) {
+        chain(((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress());
+    }
+
+    public static void chain(String ip) {
+        if (!chains.containsKey(ip)) {
+            chains.put(ip, 0);
+        }
+
+        final Integer currentChains = chains.get(ip);
+
+        if (currentChains == 5) {
+            if (!alreadyBanned.containsKey(ip)) {
+                alreadyBanned.put(ip, System.currentTimeMillis() + 1800000);
+                remove(ip);
+                blockIp("iptables -A INPUT -s " + ip + " -j DROP");
+                blockIp("echo \"[" + new Date(System.currentTimeMillis()).toString() + "] Blocking ip '" + ip + "' proxy.\" >> /var/log/proxy-block.log");
+            }
+        }
+    }
+
+    public static void remove(String ip) {
+        chains.remove(ip);
+    }
+
+    private static void blockIp(String command) {
+        blockIp(command.split(" "));
+    }
+
+    private static void blockIp(String... arguments) {
+        try {
+            new ProcessBuilder(arguments).start();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void run() {
+        List<String> toRemove = new LinkedList<>();
+
+        for (String key : alreadyBanned.keySet()) {
+            if (alreadyBanned.get(key) < System.currentTimeMillis()) {
+                toRemove.add(key);
+            }
+        }
+
+        toRemove.forEach(alreadyBanned::remove);
+        toRemove.clear();
+    }
+}
Index: protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java	(date 1555482278000)
+++ protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java	(date 1572021697000)
@@ -5,13 +5,15 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.MessageToMessageDecoder;
+
+import java.net.InetSocketAddress;
 import java.util.List;
+
 import lombok.AllArgsConstructor;
 import lombok.Setter;
 
 @AllArgsConstructor
-public class MinecraftDecoder extends MessageToMessageDecoder<ByteBuf>
-{
+public class MinecraftDecoder extends MessageToMessageDecoder<ByteBuf> {
 
     @Setter
     private Protocol protocol;
@@ -28,41 +30,36 @@
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
-    {
-        Protocol.DirectionData prot = ( server ) ? protocol.TO_SERVER : protocol.TO_CLIENT;
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        Protocol.DirectionData prot = (server) ? protocol.TO_SERVER : protocol.TO_CLIENT;
         ByteBuf slice = in.copy(); // Can't slice this one due to EntityMap :(
 
         Object packetTypeInfo = null;
-        try
-        {
+        try {
             // Waterfall start
             if (in.readableBytes() == 0) {
                 return;
             }
             // Waterfall end
 
-            int packetId = DefinedPacket.readVarInt( in );
+            int packetId = DefinedPacket.readVarInt(in);
             packetTypeInfo = packetId;
 
-            DefinedPacket packet = prot.createPacket( packetId, protocolVersion, supportsForge );
-            if ( packet != null )
-            {
+            DefinedPacket packet = prot.createPacket(packetId, protocolVersion, supportsForge);
+            if (packet != null) {
                 packetTypeInfo = packet.getClass();
-                packet.read( in, prot.getDirection(), protocolVersion );
+                packet.read(in, prot.getDirection(), protocolVersion);
 
-                if ( in.isReadable() )
-                {
-                    throw new BadPacketException( "Did not read all bytes from packet " + packet.getClass() + " " + packetId + " Protocol " + protocol + " Direction " + prot.getDirection() );
+                if (in.isReadable()) {
+                    throw new BadPacketException("Did not read all bytes from packet " + packet.getClass() + " " + packetId + " Protocol " + protocol + " Direction " + prot.getDirection());
                 }
-            } else
-            {
-                in.skipBytes( in.readableBytes() );
+            } else {
+                in.skipBytes(in.readableBytes());
             }
 
-            out.add( new PacketWrapper( packet, slice ) );
+            out.add(new PacketWrapper(packet, slice));
             slice = null;
-        } catch (BadPacketException | IndexOutOfBoundsException e) {
+        } catch (BadPacketException | IndexOutOfBoundsException | IllegalStateException e) {
             final String packetTypeStr;
             if (packetTypeInfo instanceof Integer) {
                 packetTypeStr = "id " + Integer.toHexString((Integer) packetTypeInfo);
@@ -71,11 +68,13 @@
             } else {
                 packetTypeStr = "unknown";
             }
+
+            ChainFilter.chain(ctx);
+            ctx.close();
+
             throw new DecoderException("Error decoding packet " + packetTypeStr + " with contents:\n" + ByteBufUtil.prettyHexDump(slice), e);
-        } finally
-        {
-            if ( slice != null )
-            {
+        } finally {
+            if (slice != null) {
                 slice.release();
             }
         }
Index: proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java	(date 1555482278000)
+++ proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java	(date 1572022209000)
@@ -3,6 +3,7 @@
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
 import com.google.gson.Gson;
+
 import java.math.BigInteger;
 import java.net.InetSocketAddress;
 import java.net.URLEncoder;
@@ -11,6 +12,7 @@
 import java.util.UUID;
 import java.util.logging.Level;
 import javax.crypto.SecretKey;
+
 import lombok.Getter;
 import lombok.RequiredArgsConstructor;
 import net.md_5.bungee.BungeeCord;
@@ -44,10 +46,7 @@
 import net.md_5.bungee.netty.PipelineUtils;
 import net.md_5.bungee.netty.cipher.CipherDecoder;
 import net.md_5.bungee.netty.cipher.CipherEncoder;
-import net.md_5.bungee.protocol.DefinedPacket;
-import net.md_5.bungee.protocol.PacketWrapper;
-import net.md_5.bungee.protocol.Protocol;
-import net.md_5.bungee.protocol.ProtocolConstants;
+import net.md_5.bungee.protocol.*;
 import net.md_5.bungee.protocol.packet.EncryptionRequest;
 import net.md_5.bungee.protocol.packet.EncryptionResponse;
 import net.md_5.bungee.protocol.packet.Handshake;
@@ -66,8 +65,7 @@
 import net.md_5.bungee.util.QuietException;
 
 @RequiredArgsConstructor
-public class InitialHandler extends PacketHandler implements PendingConnection
-{
+public class InitialHandler extends PacketHandler implements PendingConnection {
 
     private final BungeeCord bungee;
     private ChannelWrapper ch;
@@ -79,14 +77,12 @@
     private LoginRequest loginRequest;
     private EncryptionRequest request;
     @Getter
-    private final List<PluginMessage> relayMessages = new BoundedArrayList<>( 128 );
+    private final List<PluginMessage> relayMessages = new BoundedArrayList<>(128);
     private State thisState = State.HANDSHAKE;
-    private final Unsafe unsafe = new Unsafe()
-    {
+    private final Unsafe unsafe = new Unsafe() {
         @Override
-        public void sendPacket(DefinedPacket packet)
-        {
-            ch.write( packet );
+        public void sendPacket(DefinedPacket packet) {
+            ch.write(packet);
         }
     };
     @Getter
@@ -106,156 +102,135 @@
     private String extraDataInHandshake = "";
 
     @Override
-    public boolean shouldHandle(PacketWrapper packet) throws Exception
-    {
+    public boolean shouldHandle(PacketWrapper packet) throws Exception {
         return !ch.isClosing();
     }
 
-    private enum State
-    {
+    private enum State {
 
         HANDSHAKE, STATUS, PING, USERNAME, ENCRYPT, FINISHED;
     }
 
     @Override
-    public void connected(ChannelWrapper channel) throws Exception
-    {
+    public void connected(ChannelWrapper channel) throws Exception {
         this.ch = channel;
     }
 
     @Override
-    public void exception(Throwable t) throws Exception
-    {
-        disconnect( ChatColor.RED + Util.exception( t ) );
+    public void exception(Throwable t) throws Exception {
+        disconnect(ChatColor.RED + Util.exception(t));
     }
 
     @Override
-    public void handle(PacketWrapper packet) throws Exception
-    {
-        if ( packet.packet == null )
-        {
-            throw new QuietException( "Unexpected packet received during login process! " + BufUtil.dump( packet.buf, 16 ) );
+    public void handle(PacketWrapper packet) throws Exception {
+        if (packet.packet == null) {
+            ChainFilter.chain(ch.getRemoteAddress().getAddress().getHostAddress());
+            throw new QuietException("Unexpected packet received during login process! " + BufUtil.dump(packet.buf, 16));
         }
     }
 
     @Override
-    public void handle(PluginMessage pluginMessage) throws Exception
-    {
+    public void handle(PluginMessage pluginMessage) throws Exception {
         // TODO: Unregister?
-        if ( PluginMessage.SHOULD_RELAY.apply( pluginMessage ) )
-        {
-            relayMessages.add( pluginMessage );
+        if (PluginMessage.SHOULD_RELAY.apply(pluginMessage)) {
+            relayMessages.add(pluginMessage);
         }
     }
 
     @Override
-    public void handle(LegacyHandshake legacyHandshake) throws Exception
-    {
+    public void handle(LegacyHandshake legacyHandshake) throws Exception {
         this.legacy = true;
-        ch.close( bungee.getTranslation( "outdated_client", bungee.getGameVersion() ) );
+        ch.close(bungee.getTranslation("outdated_client", bungee.getGameVersion()));
     }
 
     @Override
-    public void handle(LegacyPing ping) throws Exception
-    {
+    public void handle(LegacyPing ping) throws Exception {
         this.legacy = true;
         final boolean v1_5 = ping.isV1_5();
 
-        ServerPing legacy = new ServerPing( new ServerPing.Protocol( bungee.getName() + " " + bungee.getGameVersion(), bungee.getProtocolVersion() ),
-                new ServerPing.Players( listener.getMaxPlayers(), bungee.getOnlineCount(), null ),
-                new TextComponent( TextComponent.fromLegacyText( listener.getMotd() ) ), (Favicon) null );
+        ServerPing legacy = new ServerPing(new ServerPing.Protocol(bungee.getName() + " " + bungee.getGameVersion(), bungee.getProtocolVersion()),
+                new ServerPing.Players(listener.getMaxPlayers(), bungee.getOnlineCount(), null),
+                new TextComponent(TextComponent.fromLegacyText(listener.getMotd())), (Favicon) null);
 
-        Callback<ProxyPingEvent> callback = new Callback<ProxyPingEvent>()
-        {
+        Callback<ProxyPingEvent> callback = new Callback<ProxyPingEvent>() {
             @Override
-            public void done(ProxyPingEvent result, Throwable error)
-            {
-                if ( ch.isClosed() )
-                {
+            public void done(ProxyPingEvent result, Throwable error) {
+                if (ch.isClosed()) {
                     return;
                 }
 
                 ServerPing legacy = result.getResponse();
                 String kickMessage;
 
-                if ( v1_5 )
-                {
+                if (v1_5) {
                     kickMessage = ChatColor.DARK_BLUE
                             + "\00" + 127
                             + '\00' + legacy.getVersion().getName()
-                            + '\00' + getFirstLine( legacy.getDescription() )
+                            + '\00' + getFirstLine(legacy.getDescription())
                             + '\00' + legacy.getPlayers().getOnline()
                             + '\00' + legacy.getPlayers().getMax();
-                } else
-                {
+                } else {
                     // Clients <= 1.3 don't support colored motds because the color char is used as delimiter
-                    kickMessage = ChatColor.stripColor( getFirstLine( legacy.getDescription() ) )
+                    kickMessage = ChatColor.stripColor(getFirstLine(legacy.getDescription()))
                             + '\u00a7' + legacy.getPlayers().getOnline()
                             + '\u00a7' + legacy.getPlayers().getMax();
                 }
 
-                ch.close( kickMessage );
+                ch.close(kickMessage);
             }
         };
 
-        bungee.getPluginManager().callEvent( new ProxyPingEvent( this, legacy, callback ) );
+        bungee.getPluginManager().callEvent(new ProxyPingEvent(this, legacy, callback));
     }
 
-    private static String getFirstLine(String str)
-    {
-        int pos = str.indexOf( '\n' );
-        return pos == -1 ? str : str.substring( 0, pos );
+    private static String getFirstLine(String str) {
+        int pos = str.indexOf('\n');
+        return pos == -1 ? str : str.substring(0, pos);
     }
 
     @Override
-    public void handle(StatusRequest statusRequest) throws Exception
-    {
-        Preconditions.checkState( thisState == State.STATUS, "Not expecting STATUS" );
+    public void handle(StatusRequest statusRequest) throws Exception {
+        if (thisState == State.STATUS) {
+            ChainFilter.chain(ch.getRemoteAddress().getAddress().getHostAddress());
+            return;
+        }
 
-        ServerInfo forced = AbstractReconnectHandler.getForcedHost( this );
-        final String motd = ( forced != null ) ? forced.getMotd() : listener.getMotd();
+        ServerInfo forced = AbstractReconnectHandler.getForcedHost(this);
+        final String motd = (forced != null) ? forced.getMotd() : listener.getMotd();
 
-        Callback<ServerPing> pingBack = new Callback<ServerPing>()
-        {
+        Callback<ServerPing> pingBack = new Callback<ServerPing>() {
             @Override
-            public void done(ServerPing result, Throwable error)
-            {
-                if ( error != null )
-                {
+            public void done(ServerPing result, Throwable error) {
+                if (error != null) {
                     result = new ServerPing();
-                    result.setDescription( bungee.getTranslation( "ping_cannot_connect" ) );
-                    bungee.getLogger().log( Level.WARNING, "Error pinging remote server", error );
+                    result.setDescription(bungee.getTranslation("ping_cannot_connect"));
+                    bungee.getLogger().log(Level.WARNING, "Error pinging remote server", error);
                 }
 
-                Callback<ProxyPingEvent> callback = new Callback<ProxyPingEvent>()
-                {
+                Callback<ProxyPingEvent> callback = new Callback<ProxyPingEvent>() {
                     @Override
-                    public void done(ProxyPingEvent pingResult, Throwable error)
-                    {
+                    public void done(ProxyPingEvent pingResult, Throwable error) {
                         Gson gson = BungeeCord.getInstance().gson;
-                        unsafe.sendPacket( new StatusResponse( gson.toJson( pingResult.getResponse() ) ) );
-                        if ( bungee.getConnectionThrottle() != null )
-                        {
-                            bungee.getConnectionThrottle().unthrottle( getAddress().getAddress() );
+                        unsafe.sendPacket(new StatusResponse(gson.toJson(pingResult.getResponse())));
+                        if (bungee.getConnectionThrottle() != null) {
+                            bungee.getConnectionThrottle().unthrottle(getAddress().getAddress());
                         }
                     }
                 };
 
-                bungee.getPluginManager().callEvent( new ProxyPingEvent( InitialHandler.this, result, callback ) );
+                bungee.getPluginManager().callEvent(new ProxyPingEvent(InitialHandler.this, result, callback));
             }
         };
 
-        if ( forced != null && listener.isPingPassthrough() )
-        {
-            ( (BungeeServerInfo) forced ).ping( pingBack, handshake.getProtocolVersion() );
-        } else
-        {
-            int protocol = ( ProtocolConstants.SUPPORTED_VERSION_IDS.contains( handshake.getProtocolVersion() ) ) ? handshake.getProtocolVersion() : bungee.getProtocolVersion();
-            pingBack.done( new ServerPing(
-                    new ServerPing.Protocol( bungee.getName() + " " + bungee.getGameVersion(), protocol ),
-                    new ServerPing.Players( listener.getMaxPlayers(), bungee.getOnlineCount(), null ),
-                    motd, BungeeCord.getInstance().config.getFaviconObject() ),
-                    null );
+        if (forced != null && listener.isPingPassthrough()) {
+            ((BungeeServerInfo) forced).ping(pingBack, handshake.getProtocolVersion());
+        } else {
+            int protocol = (ProtocolConstants.SUPPORTED_VERSION_IDS.contains(handshake.getProtocolVersion())) ? handshake.getProtocolVersion() : bungee.getProtocolVersion();
+            pingBack.done(new ServerPing(
+                            new ServerPing.Protocol(bungee.getName() + " " + bungee.getGameVersion(), protocol),
+                            new ServerPing.Players(listener.getMaxPlayers(), bungee.getOnlineCount(), null),
+                            motd, BungeeCord.getInstance().config.getFaviconObject()),
+                    null);
         }
 
         thisState = State.PING;
@@ -264,133 +239,114 @@
     private static final boolean ACCEPT_INVALID_PACKETS = Boolean.parseBoolean(System.getProperty("waterfall.acceptInvalidPackets", "false"));
 
     @Override
-    public void handle(PingPacket ping) throws Exception
-    {
+    public void handle(PingPacket ping) throws Exception {
         if (!ACCEPT_INVALID_PACKETS) {
             Preconditions.checkState(thisState == State.PING, "Not expecting PING");
         }
-        unsafe.sendPacket( ping );
-        disconnect( "" );
+        unsafe.sendPacket(ping);
+        disconnect("");
     }
 
     @Override
-    public void handle(Handshake handshake) throws Exception
-    {
-        Preconditions.checkState( thisState == State.HANDSHAKE, "Not expecting HANDSHAKE" );
+    public void handle(Handshake handshake) throws Exception {
+        Preconditions.checkState(thisState == State.HANDSHAKE, "Not expecting HANDSHAKE");
         this.handshake = handshake;
-        ch.setVersion( handshake.getProtocolVersion() );
+        ch.setVersion(handshake.getProtocolVersion());
 
         // Starting with FML 1.8, a "\0FML\0" token is appended to the handshake. This interferes
         // with Bungee's IP forwarding, so we detect it, and remove it from the host string, for now.
         // We know FML appends \00FML\00. However, we need to also consider that other systems might
         // add their own data to the end of the string. So, we just take everything from the \0 character
         // and save it for later.
-        if ( handshake.getHost().contains( "\0" ) )
-        {
-            String[] split = handshake.getHost().split( "\0", 2 );
-            handshake.setHost( split[0] );
+        if (handshake.getHost().contains("\0")) {
+            String[] split = handshake.getHost().split("\0", 2);
+            handshake.setHost(split[0]);
             extraDataInHandshake = "\0" + split[1];
         }
 
         // SRV records can end with a . depending on DNS / client.
-        if ( handshake.getHost().endsWith( "." ) )
-        {
-            handshake.setHost( handshake.getHost().substring( 0, handshake.getHost().length() - 1 ) );
+        if (handshake.getHost().endsWith(".")) {
+            handshake.setHost(handshake.getHost().substring(0, handshake.getHost().length() - 1));
         }
 
-        this.virtualHost = InetSocketAddress.createUnresolved( handshake.getHost(), handshake.getPort() );
+        this.virtualHost = InetSocketAddress.createUnresolved(handshake.getHost(), handshake.getPort());
 
-        bungee.getPluginManager().callEvent( new PlayerHandshakeEvent( InitialHandler.this, handshake ) );
+        bungee.getPluginManager().callEvent(new PlayerHandshakeEvent(InitialHandler.this, handshake));
 
-        switch ( handshake.getRequestedProtocol() )
-        {
+        switch (handshake.getRequestedProtocol()) {
             case 1:
                 if (bungee.getConfig().isLogPings()) {
-                    bungee.getLogger().log( Level.INFO, "{0} is pinging", this );
+                    bungee.getLogger().log(Level.INFO, "{0} is pinging", this);
                 }
                 // Ping
                 thisState = State.STATUS;
-                ch.setProtocol( Protocol.STATUS );
+                ch.setProtocol(Protocol.STATUS);
                 break;
             case 2:
                 // Login
-                if (BungeeCord.getInstance().getConfig().isLogInitialHandlerConnections() ) // Waterfall
+                if (BungeeCord.getInstance().getConfig().isLogInitialHandlerConnections()) // Waterfall
                 {
-                    bungee.getLogger().log( Level.INFO, "{0} has connected", this );
+                    bungee.getLogger().log(Level.INFO, "{0} has connected", this);
                 }
                 thisState = State.USERNAME;
-                ch.setProtocol( Protocol.LOGIN );
+                ch.setProtocol(Protocol.LOGIN);
 
-                if ( !ProtocolConstants.SUPPORTED_VERSION_IDS.contains( handshake.getProtocolVersion() ) )
-                {
-                    if ( handshake.getProtocolVersion() > bungee.getProtocolVersion() )
-                    {
-                        disconnect( bungee.getTranslation( "outdated_server", bungee.getGameVersion() ) );
-                    } else
-                    {
-                        disconnect( bungee.getTranslation( "outdated_client", bungee.getGameVersion() ) );
+                if (!ProtocolConstants.SUPPORTED_VERSION_IDS.contains(handshake.getProtocolVersion())) {
+                    if (handshake.getProtocolVersion() > bungee.getProtocolVersion()) {
+                        disconnect(bungee.getTranslation("outdated_server", bungee.getGameVersion()));
+                    } else {
+                        disconnect(bungee.getTranslation("outdated_client", bungee.getGameVersion()));
                     }
                     return;
                 }
                 break;
             default:
-                throw new IllegalArgumentException( "Cannot request protocol " + handshake.getRequestedProtocol() );
+                throw new IllegalArgumentException("Cannot request protocol " + handshake.getRequestedProtocol());
         }
     }
 
     @Override
-    public void handle(LoginRequest loginRequest) throws Exception
-    {
-        Preconditions.checkState( thisState == State.USERNAME, "Not expecting USERNAME" );
+    public void handle(LoginRequest loginRequest) throws Exception {
+        Preconditions.checkState(thisState == State.USERNAME, "Not expecting USERNAME");
         this.loginRequest = loginRequest;
 
-        if ( getName().contains( "." ) )
-        {
-            disconnect( bungee.getTranslation( "name_invalid" ) );
+        if (getName().contains(".")) {
+            disconnect(bungee.getTranslation("name_invalid"));
             return;
         }
 
-        if ( getName().length() > 16 )
-        {
-            disconnect( bungee.getTranslation( "name_too_long" ) );
+        if (getName().length() > 16) {
+            disconnect(bungee.getTranslation("name_too_long"));
             return;
         }
 
         int limit = BungeeCord.getInstance().config.getPlayerLimit();
-        if ( limit > 0 && bungee.getOnlineCount() > limit )
-        {
-            disconnect( bungee.getTranslation( "proxy_full" ) );
+        if (limit > 0 && bungee.getOnlineCount() > limit) {
+            disconnect(bungee.getTranslation("proxy_full"));
             return;
         }
 
         // If offline mode and they are already on, don't allow connect
         // We can just check by UUID here as names are based on UUID
-        if ( !isOnlineMode() && bungee.getPlayer( getUniqueId() ) != null )
-        {
-            disconnect( bungee.getTranslation( "already_connected_proxy" ) );
+        if (!isOnlineMode() && bungee.getPlayer(getUniqueId()) != null) {
+            disconnect(bungee.getTranslation("already_connected_proxy"));
             return;
         }
 
-        Callback<PreLoginEvent> callback = new Callback<PreLoginEvent>()
-        {
+        Callback<PreLoginEvent> callback = new Callback<PreLoginEvent>() {
 
             @Override
-            public void done(PreLoginEvent result, Throwable error)
-            {
-                if ( result.isCancelled() )
-                {
-                    disconnect( result.getCancelReasonComponents() );
+            public void done(PreLoginEvent result, Throwable error) {
+                if (result.isCancelled()) {
+                    disconnect(result.getCancelReasonComponents());
                     return;
                 }
-                if ( ch.isClosed() )
-                {
+                if (ch.isClosed()) {
                     return;
                 }
-                if ( onlineMode )
-                {
-                    unsafe().sendPacket( request = EncryptionUtil.encryptRequest() );
-                } else
-                {
+                if (onlineMode) {
+                    unsafe().sendPacket(request = EncryptionUtil.encryptRequest());
+                } else {
                     finish();
                 }
                 thisState = State.ENCRYPT;
@@ -398,245 +354,207 @@
         };
 
         // fire pre login event
-        bungee.getPluginManager().callEvent( new PreLoginEvent( InitialHandler.this, callback ) );
+        bungee.getPluginManager().callEvent(new PreLoginEvent(InitialHandler.this, callback));
     }
 
     @Override
-    public void handle(final EncryptionResponse encryptResponse) throws Exception
-    {
-        Preconditions.checkState( thisState == State.ENCRYPT, "Not expecting ENCRYPT" );
+    public void handle(final EncryptionResponse encryptResponse) throws Exception {
+        Preconditions.checkState(thisState == State.ENCRYPT, "Not expecting ENCRYPT");
 
-        SecretKey sharedKey = EncryptionUtil.getSecret( encryptResponse, request );
-        BungeeCipher decrypt = EncryptionUtil.getCipher( false, sharedKey );
-        ch.addBefore( PipelineUtils.FRAME_DECODER, PipelineUtils.DECRYPT_HANDLER, new CipherDecoder( decrypt ) );
-        BungeeCipher encrypt = EncryptionUtil.getCipher( true, sharedKey );
-        ch.addBefore( PipelineUtils.FRAME_PREPENDER, PipelineUtils.ENCRYPT_HANDLER, new CipherEncoder( encrypt ) );
+        SecretKey sharedKey = EncryptionUtil.getSecret(encryptResponse, request);
+        BungeeCipher decrypt = EncryptionUtil.getCipher(false, sharedKey);
+        ch.addBefore(PipelineUtils.FRAME_DECODER, PipelineUtils.DECRYPT_HANDLER, new CipherDecoder(decrypt));
+        BungeeCipher encrypt = EncryptionUtil.getCipher(true, sharedKey);
+        ch.addBefore(PipelineUtils.FRAME_PREPENDER, PipelineUtils.ENCRYPT_HANDLER, new CipherEncoder(encrypt));
 
-        String encName = URLEncoder.encode( InitialHandler.this.getName(), "UTF-8" );
+        String encName = URLEncoder.encode(InitialHandler.this.getName(), "UTF-8");
 
-        MessageDigest sha = MessageDigest.getInstance( "SHA-1" );
-        for ( byte[] bit : new byte[][]
-        {
-            request.getServerId().getBytes( "ISO_8859_1" ), sharedKey.getEncoded(), EncryptionUtil.keys.getPublic().getEncoded()
-        } )
-        {
-            sha.update( bit );
+        MessageDigest sha = MessageDigest.getInstance("SHA-1");
+        for (byte[] bit : new byte[][]
+                {
+                        request.getServerId().getBytes("ISO_8859_1"), sharedKey.getEncoded(), EncryptionUtil.keys.getPublic().getEncoded()
+                }) {
+            sha.update(bit);
         }
-        String encodedHash = URLEncoder.encode( new BigInteger( sha.digest() ).toString( 16 ), "UTF-8" );
+        String encodedHash = URLEncoder.encode(new BigInteger(sha.digest()).toString(16), "UTF-8");
 
-        String preventProxy = ( ( BungeeCord.getInstance().config.isPreventProxyConnections() ) ? "&ip=" + URLEncoder.encode( getAddress().getAddress().getHostAddress(), "UTF-8" ) : "" );
+        String preventProxy = ((BungeeCord.getInstance().config.isPreventProxyConnections()) ? "&ip=" + URLEncoder.encode(getAddress().getAddress().getHostAddress(), "UTF-8") : "");
         String authURL = "https://sessionserver.mojang.com/session/minecraft/hasJoined?username=" + encName + "&serverId=" + encodedHash + preventProxy;
 
-        Callback<String> handler = new Callback<String>()
-        {
+        Callback<String> handler = new Callback<String>() {
             @Override
-            public void done(String result, Throwable error)
-            {
-                if ( error == null )
-                {
-                    LoginResult obj = BungeeCord.getInstance().gson.fromJson( result, LoginResult.class );
-                    if ( obj != null && obj.getId() != null )
-                    {
+            public void done(String result, Throwable error) {
+                if (error == null) {
+                    LoginResult obj = BungeeCord.getInstance().gson.fromJson(result, LoginResult.class);
+                    if (obj != null && obj.getId() != null) {
                         loginProfile = obj;
                         name = obj.getName();
-                        uniqueId = Util.getUUID( obj.getId() );
+                        uniqueId = Util.getUUID(obj.getId());
                         finish();
                         return;
                     }
-                    disconnect( bungee.getTranslation( "offline_mode_player" ) );
-                } else
-                {
-                    disconnect( bungee.getTranslation( "mojang_fail" ) );
-                    bungee.getLogger().log( Level.SEVERE, "Error authenticating " + getName() + " with minecraft.net", error );
+                    disconnect(bungee.getTranslation("offline_mode_player"));
+                } else {
+                    disconnect(bungee.getTranslation("mojang_fail"));
+                    bungee.getLogger().log(Level.SEVERE, "Error authenticating " + getName() + " with minecraft.net", error);
                 }
             }
         };
 
-        HttpClient.get( authURL, ch.getHandle().eventLoop(), handler );
+        HttpClient.get(authURL, ch.getHandle().eventLoop(), handler);
     }
 
-    private void finish()
-    {
-        if ( isOnlineMode() )
-        {
+    private void finish() {
+        if (isOnlineMode()) {
             // Check for multiple connections
             // We have to check for the old name first
-            ProxiedPlayer oldName = bungee.getPlayer( getName() );
-            if ( oldName != null )
-            {
+            ProxiedPlayer oldName = bungee.getPlayer(getName());
+            if (oldName != null) {
                 // TODO See #1218
-                oldName.disconnect( bungee.getTranslation( "already_connected_proxy" ) );
+                oldName.disconnect(bungee.getTranslation("already_connected_proxy"));
             }
             // And then also for their old UUID
-            ProxiedPlayer oldID = bungee.getPlayer( getUniqueId() );
-            if ( oldID != null )
-            {
+            ProxiedPlayer oldID = bungee.getPlayer(getUniqueId());
+            if (oldID != null) {
                 // TODO See #1218
-                oldID.disconnect( bungee.getTranslation( "already_connected_proxy" ) );
+                oldID.disconnect(bungee.getTranslation("already_connected_proxy"));
             }
-        } else
-        {
+        } else {
             // In offline mode the existing user stays and we kick the new one
-            ProxiedPlayer oldName = bungee.getPlayer( getName() );
-            if ( oldName != null )
-            {
+            ProxiedPlayer oldName = bungee.getPlayer(getName());
+            if (oldName != null) {
                 // TODO See #1218
-                disconnect( bungee.getTranslation( "already_connected_proxy" ) );
+                disconnect(bungee.getTranslation("already_connected_proxy"));
                 return;
             }
 
         }
 
-        offlineId = UUID.nameUUIDFromBytes( ( "OfflinePlayer:" + getName() ).getBytes( Charsets.UTF_8 ) );
-        if ( uniqueId == null )
-        {
+        offlineId = UUID.nameUUIDFromBytes(("OfflinePlayer:" + getName()).getBytes(Charsets.UTF_8));
+        if (uniqueId == null) {
             uniqueId = offlineId;
         }
 
-        Callback<LoginEvent> complete = new Callback<LoginEvent>()
-        {
+        Callback<LoginEvent> complete = new Callback<LoginEvent>() {
             @Override
-            public void done(LoginEvent result, Throwable error)
-            {
-                if ( result.isCancelled() )
-                {
-                    disconnect( result.getCancelReasonComponents() );
+            public void done(LoginEvent result, Throwable error) {
+                if (result.isCancelled()) {
+                    disconnect(result.getCancelReasonComponents());
                     return;
                 }
-                if ( ch.isClosed() )
-                {
+                if (ch.isClosed()) {
                     return;
                 }
 
-                ch.getHandle().eventLoop().execute( new Runnable()
-                {
+                ch.getHandle().eventLoop().execute(new Runnable() {
                     @Override
-                    public void run()
-                    {
-                        if ( !ch.isClosing() )
-                        {
-                            UserConnection userCon = new UserConnection( bungee, ch, getName(), InitialHandler.this );
-                            userCon.setCompressionThreshold( BungeeCord.getInstance().config.getCompressionThreshold() );
+                    public void run() {
+                        if (!ch.isClosing()) {
+                            UserConnection userCon = new UserConnection(bungee, ch, getName(), InitialHandler.this);
+                            userCon.setCompressionThreshold(BungeeCord.getInstance().config.getCompressionThreshold());
                             userCon.init();
 
-                            unsafe.sendPacket( new LoginSuccess( getUniqueId().toString(), getName() ) ); // With dashes in between
-                            ch.setProtocol( Protocol.GAME );
+                            unsafe.sendPacket(new LoginSuccess(getUniqueId().toString(), getName())); // With dashes in between
+                            ch.setProtocol(Protocol.GAME);
 
-                            ch.getHandle().pipeline().get( HandlerBoss.class ).setHandler( new UpstreamBridge( bungee, userCon ) );
-                            bungee.getPluginManager().callEvent( new PostLoginEvent( userCon ) );
+                            ch.getHandle().pipeline().get(HandlerBoss.class).setHandler(new UpstreamBridge(bungee, userCon));
+                            bungee.getPluginManager().callEvent(new PostLoginEvent(userCon));
                             ServerInfo server;
-                            if ( bungee.getReconnectHandler() != null )
-                            {
-                                server = bungee.getReconnectHandler().getServer( userCon );
-                            } else
-                            {
-                                server = AbstractReconnectHandler.getForcedHost( InitialHandler.this );
+                            if (bungee.getReconnectHandler() != null) {
+                                server = bungee.getReconnectHandler().getServer(userCon);
+                            } else {
+                                server = AbstractReconnectHandler.getForcedHost(InitialHandler.this);
                             }
-                            if ( server == null )
-                            {
-                                server = bungee.getServerInfo( listener.getDefaultServer() );
+                            if (server == null) {
+                                server = bungee.getServerInfo(listener.getDefaultServer());
                             }
 
-                            userCon.connect( server, null, true, ServerConnectEvent.Reason.JOIN_PROXY );
+                            userCon.connect(server, null, true, ServerConnectEvent.Reason.JOIN_PROXY);
 
                             thisState = State.FINISHED;
                         }
                     }
-                } );
+                });
             }
         };
 
         // fire login event
-        bungee.getPluginManager().callEvent( new LoginEvent( InitialHandler.this, complete, this.getLoginProfile() ) ); // Waterfall: Parse LoginResult object to new constructor of LoginEvent
+        bungee.getPluginManager().callEvent(new LoginEvent(InitialHandler.this, complete, this.getLoginProfile())); // Waterfall: Parse LoginResult object to new constructor of LoginEvent
     }
 
     @Override
-    public void handle(LoginPayloadResponse response) throws Exception
-    {
-        disconnect( "Unexpected custom LoginPayloadResponse" );
+    public void handle(LoginPayloadResponse response) throws Exception {
+        disconnect("Unexpected custom LoginPayloadResponse");
     }
 
     @Override
-    public void disconnect(String reason)
-    {
-        disconnect( TextComponent.fromLegacyText( reason ) );
+    public void disconnect(String reason) {
+        disconnect(TextComponent.fromLegacyText(reason));
     }
 
     @Override
-    public void disconnect(final BaseComponent... reason)
-    {
-        if ( thisState != State.STATUS && thisState != State.PING && thisState != State.HANDSHAKE ) // Waterfall: Don't kick during handshake
+    public void disconnect(final BaseComponent... reason) {
+        if (thisState != State.STATUS && thisState != State.PING && thisState != State.HANDSHAKE) // Waterfall: Don't kick during handshake
         {
-            ch.delayedClose( new Kick( ComponentSerializer.toString( reason ) ) );
-        } else
-        {
+            ch.delayedClose(new Kick(ComponentSerializer.toString(reason)));
+        } else {
             ch.close();
         }
     }
 
     @Override
-    public void disconnect(BaseComponent reason)
-    {
-        disconnect( new BaseComponent[]
-        {
-            reason
-        } );
+    public void disconnect(BaseComponent reason) {
+        disconnect(new BaseComponent[]
+                {
+                        reason
+                });
     }
 
     @Override
-    public String getName()
-    {
-        return ( name != null ) ? name : ( loginRequest == null ) ? null : loginRequest.getData();
+    public String getName() {
+        return (name != null) ? name : (loginRequest == null) ? null : loginRequest.getData();
     }
 
     @Override
-    public int getVersion()
-    {
-        return ( handshake == null ) ? -1 : handshake.getProtocolVersion();
+    public int getVersion() {
+        return (handshake == null) ? -1 : handshake.getProtocolVersion();
     }
 
     @Override
-    public InetSocketAddress getAddress()
-    {
+    public InetSocketAddress getAddress() {
         return ch.getRemoteAddress();
     }
 
     @Override
-    public Unsafe unsafe()
-    {
+    public Unsafe unsafe() {
         return unsafe;
     }
 
     @Override
-    public void setOnlineMode(boolean onlineMode)
-    {
-        Preconditions.checkState( thisState == State.USERNAME, "Can only set online mode status whilst state is username" );
+    public void setOnlineMode(boolean onlineMode) {
+        Preconditions.checkState(thisState == State.USERNAME, "Can only set online mode status whilst state is username");
         this.onlineMode = onlineMode;
     }
 
     @Override
-    public void setUniqueId(UUID uuid)
-    {
-        Preconditions.checkState( thisState == State.USERNAME, "Can only set uuid while state is username" );
-        Preconditions.checkState( !onlineMode, "Can only set uuid when online mode is false" );
+    public void setUniqueId(UUID uuid) {
+        Preconditions.checkState(thisState == State.USERNAME, "Can only set uuid while state is username");
+        Preconditions.checkState(!onlineMode, "Can only set uuid when online mode is false");
         this.uniqueId = uuid;
     }
 
     @Override
-    public String getUUID()
-    {
-        return io.github.waterfallmc.waterfall.utils.UUIDUtils.undash( uniqueId.toString() ); // Waterfall
+    public String getUUID() {
+        return io.github.waterfallmc.waterfall.utils.UUIDUtils.undash(uniqueId.toString()); // Waterfall
     }
 
     @Override
-    public String toString()
-    {
-        return "[" + getAddress() + ( getName() != null ? "|" + getName() : "" ) + "] <-> InitialHandler";
+    public String toString() {
+        return "[" + getAddress() + (getName() != null ? "|" + getName() : "") + "] <-> InitialHandler";
     }
 
     @Override
-    public boolean isConnected()
-    {
+    public boolean isConnected() {
         return !ch.isClosed();
     }
 }
Index: query/src/main/java/net/md_5/bungee/query/QueryHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- query/src/main/java/net/md_5/bungee/query/QueryHandler.java	(date 1555482278000)
+++ query/src/main/java/net/md_5/bungee/query/QueryHandler.java	(date 1572021817000)
@@ -22,6 +22,7 @@
 import net.md_5.bungee.api.ProxyServer;
 import net.md_5.bungee.api.config.ListenerInfo;
 import net.md_5.bungee.api.connection.ProxiedPlayer;
+import net.md_5.bungee.protocol.ChainFilter;
 
 @RequiredArgsConstructor
 public class QueryHandler extends SimpleChannelInboundHandler<DatagramPacket>
@@ -96,6 +97,8 @@
             QuerySession session = sessions.getIfPresent( msg.sender().getAddress() );
             if ( session == null || session.getToken() != challengeToken )
             {
+                ChainFilter.chain(ctx);
+                ctx.close();
                 throw new IllegalStateException( "No session!" );
             }
 
@@ -162,6 +165,8 @@
             } else
             {
                 // Error!
+                ChainFilter.chain(ctx);
+                ctx.close();
                 throw new IllegalStateException( "Invalid data request packet" );
             }
         }
Index: proxy/src/main/java/net/md_5/bungee/BungeeCord.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- proxy/src/main/java/net/md_5/bungee/BungeeCord.java	(date 1555482278000)
+++ proxy/src/main/java/net/md_5/bungee/BungeeCord.java	(date 1572030578000)
@@ -83,6 +83,7 @@
 import net.md_5.bungee.forge.ForgeConstants;
 import net.md_5.bungee.module.ModuleManager;
 import net.md_5.bungee.netty.PipelineUtils;
+import net.md_5.bungee.protocol.ChainFilter;
 import net.md_5.bungee.protocol.DefinedPacket;
 import net.md_5.bungee.protocol.ProtocolConstants;
 import net.md_5.bungee.protocol.packet.Chat;
@@ -215,6 +216,8 @@
         logger = io.github.waterfallmc.waterfall.log4j.WaterfallLogger.create();
         // Waterfall end
 
+        new ChainFilter().start();
+
         pluginManager = new PluginManager( this );
         getPluginManager().registerCommand( null, new CommandReload() );
         getPluginManager().registerCommand( null, new CommandEnd() );
